#!/bin/bash

# Bash strict mode
set -euo pipefail
IFS=$'\n\t'

# make stdout available as fd 3 for the result
exec 3>&1
# redirect all output to stderr for logging
exec 1>&2

# read the json from /dev/stdin and save to /tmp/input.json
jq -M -S . < /dev/stdin > /tmp/input.json
# '-M' monochrome (don't colorize JSON);
# '-S' sort keys of objects on output;

url=$(jq -r .source.url < /tmp/input.json)

case "$0" in
    ('/opt/resource/check')
        sha256=$(curl --head "$url" \
            | grep -i -e ^Last-Modified -e ^Content-Length \
            | sha256sum | awk '{print $1}')
        json=$(cat <<ENDLINE
[
  {
    "digest": "sha256:$sha256"
  }
]
ENDLINE
)
        ;;
    ('/opt/resource/in')
        cd "$1" # /tmp/build/get
        curl --dump-header /tmp/header.log "$url" > "$(basename "$url")"
        sha256=$(grep -i -e ^Last-Modified -e ^Content-Length /tmp/header.log \
            | sha256sum | awk '{print $1}')
        length=$(grep -i -e ^Content-Length /tmp/header.log \
            | awk '{print $1}')
        modified=$(grep -i -e ^Last-Modified /tmp/header.log \
            | cut -d ' ' -f 2-)
        json=$(cat <<ENDLINE
{
  "version": {
    "digest": "sha256:$sha256"
  },
  "metadata": [
    {
      "name": "url",
      "value": "$url"
    },
    {
      "name": "Last-Modified",
      "value": "$modified"
    },
    {
      "name": "Content-Length",
      "value": "$length"
    }
  [
}
ENDLINE
)
        ;;
    ('/opt/resource/out')
        cd "$1" # /tmp/build/put
        json='{}' # noop
        ;;
esac

# output the json to fd 3
jq -n "$json" >&3
# '-n' Don't read from stdin
